### [HTTP文章](https://interview2.poetries.top/docs/fe-base/http-protocol/base/01-HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html)
## 什么是HTTP、HTTP2、HTTPS有什么区别？
**概念：**
> http是一种超文本传输协议，在OSI模型七层中的第七层应用层，也是建立在TCP/IP之上。和TCP/UDP协议类似，实际传输数据都需要附加一些头部数据。不过与 TCP/UDP 不同的是，它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。我们现在最常用的是http1.1版本。

**极大特性**：
* HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
* HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
* HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
* HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
* HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息（可以借住cookie达到有状态的效果）

**数据传输相关头字段：**
* 数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept和 Content-Type；
* 数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；
* 语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；
* 字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset和 Content-Type；
* 客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据； Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重;

如图：
![](https://s.poetries.work/gitee/2019/12/17.png)

**传输大文件相关头字段：**
* **数据压缩**：浏览器在发送请求时都会带着“Accept-Encoding”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br 等(压缩文本效果好)。
* **分块传输**：在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。
* **范围请求**：想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求的”。

> 总结：
* 压缩 HTML 等文本文件是传输大文件最基本的方法；
* 分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；
* 范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；
* 也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔；

**http连接管理相关：**
* **短连接**：http1.1之前都是短连接，它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。频繁的打开和关闭链接服务器压力很大。
* **长链接**：在第一次请求建立链接后，不关闭。HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。如果服务器支持长连接，它总会在响应报文里放一个“Connection: keep-alive”字段。

* **队头阻塞问题：**
“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。

> 总结：
* 早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；
* HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；
* 服务器会发送“Connection: keep-alive”字段表示启用了长连接；
* 报文头里如果有“Connection: close”就意味着长连接即将关闭；
* 过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；
* “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解


## HTTP2以及特性？
**概念：**
> http2是http1.1的下一个版本。http2对之前版本做了功能上的兼容，由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是改进性能。特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议。

**兼容HTTP：**
> 因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了“语义”和“语法”两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。

[HTTP2特性文章](https://blog.csdn.net/qq_36885515/article/details/123137845)

**几大特性：**
1. **头部压缩**：HTTP/2头部通过HPACK算法进行压缩，这种算法通过服务端和客户端各自维护索引表来实现。索引表又分为静态表和动态表。客户端通过传输索引号（不需要在传输），服务端根据索引号在动态表中获取Header的key与value，，极大减少了报文大小。静态表中的字段和值固定，而且是只读的。

2. **二进制分帧**：http2采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

* **流**：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）；

* **消息**：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。

* **帧**：HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流，承载着特定类型的数据，如 HTTP 首部、负荷，等等

HTTP/2引入的二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。
我们说的 **多路复用** 进行链连接管理，性能极大提升。
* 同域名下所有通信都在单个连接上完成
* 单个连接可以承载任意数量的双向数据流
* 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

多路复用 如图：
![http1.1](https://img-blog.csdnimg.cn/img_convert/77326229caec25518033e4657c34c127.png)
![http2](https://img-blog.csdnimg.cn/img_convert/cc90718be527808c86ef5e470bb5fea6.png)

3. **服务器推送（server push）**：在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。
![服务器推送](https://img-blog.csdnimg.cn/img_convert/112dd6aeba0448002e95f0a95ce5e78d.png)

>安全方面：http2虽然表面上是明文传递，但事实上http2是加密的。互联网上通常所能见到的 HTTP/2 都是使用“https”协议名，跑在 TLS 上面（要求下层的通信协议必须是 TLS1.2 以上）。为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。

> 3种协议结构图
![结构图](https://s.poetries.work/gitee/2019/12/64.png)

> http2总结：
* HTTP 协议取消了小版本号，所以 HTTP/2 的正式名字不是 2.0；
* HTTP/2 在“语义”上兼容 HTTP/1，保留了请求方法、URI 等传统概念；
* HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；
* HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；
* HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；
* HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件

## HTTP/1.x keep-alive 与 HTTP/2多路复用区别？
* HTTP/1.x 是基于文本的，只能整体去传;HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送

* HTTP/1.x keep-alive 必须按照请求发送的顺序返回响应;HTTP/2 多路复用不按序响应

* HTTP/1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接;HTTP/2  同域名下所有通信都在单个连接上完成

* HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求(两个请求的生命周期不能重叠);HTTP/2 单个 TCP  同一时刻可以发送多个请求和响应

---
## HTTP的报文结构（请求报文和响应报文）？
* 起始行（请求行/状态行）：描述请求或响应的基本信息；
* 头部字段（请求报头/响应报头）：描述一些详细的报文信息；
* 消息正文（请求正文/响应正文）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据；

前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”
HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。
整体结构如图：
![报文的整体结构](https://s.poetries.work/gitee/2019/12/6.png)

请求行由三部分构成：
* 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
* 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
* 版本号：表示报文使用的 HTTP 协议版本；

状态行也是由三部分构成：
* 版本号：表示报文使用的 HTTP 协议版本；
* 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；
* 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因；


头部字段（请求头和响应头）：
头部字段是 key-value 的形式，key 和 value 之间用“:”分隔。
> HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。

## HTTP的URI结构？
**概念**： 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
![URI结构图](https://s.poetries.work/gitee/2019/12/13.png)

### HTTP的请求方式、区别？

### 常见的HTTP状态吗？301和302的区别？
### 常见的HTTP请求头？
##  TCP的三次握手？
1. 客户端发送 SYN seq=0，状态变为 SYN_SENT
2. 服务端发送 SYN seq=0 ack=1，状态变为 SYN_RCVD
3. 客户端发送 seq=1 ack=1，两端状态都变成已建立连接状态

## 四次挥手
1. 客户端发送 FIN seq=0 ack=0，状态变为 FIN_WAIT_1
2. 服务端发送 ack=1，状态变为 CLOSE_WAIT，客户端状态变为 FIN_WAIT_2（只收不发）
3. 服务端发送 FIN seq=1，状态变为 LAST_ACK，客户端变为 TIME_WAIT
4. 客户端发送 ack=2，服务端状态变为 CLOSE

### TCP和UDP的区别？
### 强缓存和协商缓存？
### 浏览器的缓存？
### fetch发送2次请求的原因？
当使用fetch发送POST请求时，会先发送一个OPTION请求进行预检查，用来获知服务端是否允许该跨域请求，服务器确认允许之后会返回204状态码，表示允许该跨域请求，这时才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）
### Cookie，sessionStorage，localStorage的区别？session？是否可以跨域获取缓存
### Cookie 如何防范 XSS 攻击？
## HTTPS？
**对称加密**:  
就是指加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。  
**非对称加密**：


1、CDN是什么？
CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；

1、介绍Http2，优点和存在什么坑或问题（必考）
2、HTTP报文的请求和返回会有几个部分（请求行、请求头、请求体）；每部分具体都有什么（常见的请求头）
3、GET和POST的区别
4、输入url到页面加载全过程（必考）
5、介绍HTTPS；HTTP和HTTPS的区别（必考）
6、HTTPS加密过程
7、HTTP缓存控制（强缓存、弱缓存）；缓存相关的HTTP请求头（必考）
8、对跨域的了解，跨域怎么解决（必考）
9、cors的返回头、cors预请求，什么时候会出发预请求（必考）
10、tcp的长连接和http2多路复用相关
11、tcp拥塞控制和流量控制
12、三次握手四次挥手，为什么三次和四次

### 面试要看的
https://juejin.cn/post/6948576107163549732?utm_source=gold_browser_extension
